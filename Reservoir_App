# In Postico
CREATE TABLE reservoir_data
(docid text, sentid integer, wordid integer[], words text[], poses text[], ners text[], lemmas text[], dep_paths text[], dep_parents integer []);
COPY reservoir_data FROM '/Users/erikaito/Documents/Erika_DeepDive/sentences_nlp352' WITH delimiter as '	';

# In R
# Load Libraries
library("RPostgreSQL")
library("doParallel")
library(pbapply)
#install and load RCurl package to use getURL function
install.packages("RCurl")
library(RCurl)

# Connect to postgresql
Driver <- dbDriver("PostgreSQL") # Establish database driver
Connection <- dbConnect(Driver, dbname = "erikaito", host = "localhost", port = 5432, user = "erikaito")
DeepDiveData<-dbGetQuery(Connection,"SELECT * FROM reservoir_data")

#Select words of interest
ReservoirDictionary<-c("aquifer","reservoir","aquitard","aquiclude","water","oil","gas","coal","aquifuge")
# Make vector of upper case words and add it to the original vector
ReservoirDictionary<-c(ReservoirDictionary,gsub("(^[[:alpha:]])", "\\U\\1", ReservoirDictionary, perl=TRUE))

# Download dictionary of unit names from Macrostrat Database
UnitsURL<-paste("https://dev.macrostrat.org/api/units?project_id=1&format=csv")
GotURL<-getURL(UnitsURL)
UnitsFrame<-read.csv(text=GotURL,header=TRUE)


# write function to find parents of reservoir words in DeepDive documents
findParents<-function(DocRow,FirstDictionary=ReservoirDictionary) {
    CleanedWords<-gsub("\\{|\\}","",DocRow["words"])
    CleanedWords<-gsub("\",\"","COMMASUB",CleanedWords)
    CleanedParents<-gsub("\\{|\\}","",DocRow["dep_parents"])
    SplitParents<-unlist(strsplit(CleanedParents,","))
    SplitWords<-unlist(strsplit(CleanedWords,","))
    FoundWords<-SplitWords%in%FirstDictionary
    
    # Create columns for final matrix
    MatchedWords<-SplitWords[which(FoundWords)]
    FoundParents<-SplitWords[as.numeric(SplitParents[which(FoundWords)])]
    DocumentID<-rep(DocRow["docid"],length(MatchedWords))
    SentenceID<-rep(DocRow["sentid"],length(MatchedWords))
  	
    # Account for words with missing parents 
    if (length(FoundParents)<1) {
        FoundParents<-rep(NA,length(MatchedWords))
        }
  	    
    # Return the function output
    return(cbind(MatchedWords,FoundParents,DocumentID,SentenceID))
    }
  
# Apply findParents function to DeepDiveData to get matched words data
DDResults<-pbapply(DeepDiveData,1,findParents,ReservoirDictionary)
DDResultsMatrix<-do.call(rbind,DDResults)

##############

# Create a vector of all unique unit words
Vector<-c(as.character(UnitsFrame[,"Mbr"]),as.character(UnitsFrame[,"Fm"]),as.character(UnitsFrame[,"Gp"]),as.character(UnitsFrame[,"SGp"]))
unique(Vector)
VECTOR<-subset(Vector,Vector!="")
NumUnits<-1:length(VECTOR)
UnitDictionary<-vector("list",length=length(VECTOR))

# Create dictionary list of matrices of split unit words
for(UnitElement in NumUnits){
    UnitDictionary[[UnitElement]]<-unlist(strsplit(noquote(gsub(" ","SPLIT",VECTOR[UnitElement])),"SPLIT"))
    }

# Pull out the first word of every matrix in the UnitDictionary list
FirstWords<-unique(sapply(UnitDictionary,function(x) x[1]))

# Find matches of FirstWords in all of the DeepDiveData documents
# Get data for the word matches (word match, poses, documentID, adn sentenceID)
findPoses<-function(DocRow,FirstDictionary=FirstWords) {
  CleanedWords<-gsub("\\{|\\}","",DocRow["words"])
    CleanedPoses<-gsub("\\{|\\}","",DocRow["poses"])
    SplitPoses<-unlist(strsplit(CleanedPoses,","))
    SplitWords<-unlist(strsplit(CleanedWords,","))
  	FoundWords<-SplitWords%in%FirstDictionary
  	
  	# Create columns for final matrix
  	MatchedWords<-SplitWords[which(FoundWords)]
  	FoundPose<-SplitPoses[which(FoundWords)]
    DocumentID<-rep(DocRow["docid"],length(MatchedWords))
    SentenceID<-rep(DocRow["sentid"],length(MatchedWords))
  	    
    # Return the function output
    return(cbind(MatchedWords,FoundPose,DocumentID,SentenceID))
    }
  	
# Apply function to DeepDiveData documents
DDResults2<-pbapply(DeepDiveData,1,findPoses,FirstWords)
  	
  	
  ##########
  
  
  
  
  
  	
  	DocumentID<-rep(DocRow["docid"],length(MatchedWords))
  	SentenceID<-rep(DocRow["sentid"],length(MatchedWords))
  	
  	# Account for words with missing parents 
  	if (length(FoundParents)<1) {
  	    FoundParents<-rep(NA,length(MatchedWords))
  	    }
  	    
  	# Return the function output
  	return(cbind(MatchedWords,FoundParents,DocumentID,SentenceID))
  	}


###############
Sub<-gsub(" ","SPLIT",UnitDictionary[8819])
SplitUnitsList<-strsplit(noquote(Sub),"SPLIT")
SplitUnits<-unlist(SplitUnitsList)

SplitUnitsList<-vector("list",length=1:UnitDictionary)
SplitUnitsList<-vector("list",length=length(UnitDictionary))

unlist(strsplit(noquote(gsub(" ","SPLIT",UnitDictionary[UnitElement])),"SPLIT"))
